library(orthopolynom) # for hermite polynomials
library(mvtnorm) # for multivariate Gaussian density


# .........................................................
# Generate FARIMA(0,d,0)
# Inputs:
#  T: length of the series
#  d: memory parameter
# .........................................................


farima.sim <- function(Tt,d){
  r <- rep(0,2*Tt-2)
  r[1] <- gamma(1-2*d)/(gamma(1-d)^2)
  r[2:Tt] <- gamma(1-2*d)/gamma(d)/gamma(1-d)*exp(lgamma((1:(Tt-1))+d)-lgamma((1:(Tt-1))-d+1))
  r[(Tt+1):(2*Tt-2)] <- rev(r[2:(Tt-1)])

  L <- Re(fft(r))
  wr <- rnorm(2*Tt-2,0,1)
  wi <- rnorm(2*Tt-2,0,1)
  w <- wr + 1i*wi
  w2 <- sqrt(L/(2*Tt-2))*w

  z <- fft(w2)
  return(Re(z[1:Tt]))
}

# .........................................................
# Generate Poisson-FARIMA(0,d,0) model
# Inputs:
#  T: length of the series
#  lam: Poisson lambda parameter
#  d: memory parameter
# .........................................................

pois.farima <- function(Tt,d,lam){
  zt <- farima.sim(Tt,d)*gamma(1-d)/sqrt(gamma(1-2*d))
  xt <- qpois(pnorm(zt,0,1),lam)
  return(xt)
}


############################################################################

Q <- function(x){ qpois(x, lambda = 2) } # F^(-1)

Polys <- hermite.he.polynomials(100) # polys[[k]] = H_{k-1}

# ---- g() from equation (23) on 1-31-18 ----
g <- function(lam, k, polys=Polys){
  her <- as.function(polys[[k]]) # polys[[k]] = H_{k-1}
  N = which(round(ppois(1:100, lam), 7) == 1)[1]
  terms = exp(-qnorm(ppois(0:N, lam, lower.tail= TRUE))^2/2) *
    her(qnorm(ppois(0:N, lam, lower.tail = TRUE)))
  return(list(val=sum(terms)/sqrt(2*pi)/factorial(k), terms=terms))
}
# ----

# --- ACVF of FARIMA(0,d,0) ---
acf.farima0d0 = function(d,h){
  if(h==0) return(1)
  k = 1:h
  prod((k-1+d)/(k-d))
}
#

# ---- ACVF of X. Equation (9) on 1-31-18 ----
gamy = function(h, d, gvec, max.terms=30){
  sum(gvec^2 * factorial(1:max.terms) * (acf.farima0d0(d,h))^(1:max.terms))
}
# ----

# ---- likelihood function ----
lik = function(theta, data){
  lam = theta[1]
  d   = theta[2]
  n   = length(data)
  h   = 0:(n-1)
  gvec = c()
  for(i in 1:30){gvec[i] <- g(lam = lam, k = i)$val}
  gamy.vec = c()
  for(i in 1:length(h)){gamy.vec[i] = gamy(h[i], d=d, gvec=gvec)}
  Sigma = toeplitz(gamy.vec)
  out = -2*dmvnorm(as.numeric(data), mean = rep(lam, n), sigma = Sigma, log = TRUE)
  return(out)
}
# ----

# ---- Single likelihood evaluation ----
d = .25
n = 200
lam = 2
y = pois.farima(Tt=n,d=d,lam=lam)
lik(theta = c(lam, d), data = y)
# ----

# ---- plot likelihood ~ d ----
# d.seq = seq(.1, .3, length.out = 100)
# d = .2
# n = 500
# lam = 2
# y = pois.farima(Tt=n,d=.25,lam=lam)
# likvec = c()
# for(i in 1:length(d.seq)){
#   if(i%%10==0) print(i)
#   likvec[i] = lik(theta = c(lam, d.seq[i]), data = y)
# }
# plot(likvec~d.seq)
# ----


# ---- Nsim replications of optim for liklihood ----
lam = 2
d = .4
n = 400
Nsim = 10^3
p = matrix(nrow=Nsim, ncol=2)
colnames(p) = c("lambda", "d")
pb <- txtProgressBar(min=2,max=Nsim,style=3)
for(i in 1:Nsim){
  y = pois.farima(Tt=n,d=d,lam=lam)
  out = optim(par = c(lam, d), fn = lik, data=y)
  p[i,] = out$par
  setTxtProgressBar(pb,i)
}
close(pb)
# ----




